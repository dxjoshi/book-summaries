###TODOs
- Create a list of all technologies and tools that you would like to learn. 
Now label each of them with a different priority: “This Week”, “Next Month”, “Next Year”. 
Whenever you feel like you’re missing out on some new shiny trend, revisit this list and reorganize the priority.       

- Spend some time researching what the fundamental concepts in your field are. Grab a piece of paper and divide it into two columns. 
On the left side, list all the knowledge that you already have. 
On the right side, list all the knowledge that you still need to acquire. 
Plan a dedicated time of your day to study those concepts.       

- Find an event online and submit a presentation. Open a screen share software and record yourself doing something. Create a blog and share an article. Choose any topic that you want to learn and try to teach it instead.        

- Programming is an infinite game, even though most of us act like it’s a finite game. 
Are you playing a finite or infinite game? 
How much time do you spend going after short-term gains vs. investing time in long-term outcomes?          

- Open a current project that you’re working on. Is there any refactoring you could do to make the life of your future self easier?

- Think about the skills you think could be improved. Can you plan some extra time to develop them? Even 10 minutes a day could make a difference.      

- For the next few days pay attention to the apps you use the most. Is there anything missing from them? Would you be able to create a better version of that? Have a dedicated notebook for all of your side project ideas and take it everywhere with you. When you’re ready, pick one of those ideas and give it a try.

- Think about the three things you love the most about your current job. Now think about the three things you hate the most about your current job. Is there anything you can do to turn those bad parts into good parts? Are these changes outside of your control or not?

- At your next meeting, choose to practice your listening skills. Instead of being the first to say something, wait until everybody shared their ideas, and be the last one to speak. This will give everybody else the feeling of being heard, plus you have the benefit of listening to everyone’s ideas before sharing your own opinions.                    

- Next time someone asks for an estimate, grab a Post-it and take a note of your answer. When you are ready to begin the task, start a clock and see how long it takes to complete. Once the task is done, take a note of how many hours it actually took to finish. Repeat the same thing for the next task.            

- Examine your work day. Examine your work week. What are the parts that drive you the most? What type of work would you rather do? Examine your company. Examine your team. What are they struggling the most? Is there anything you can help with?

- What are the variables that you’re worried about now? How many of them are out of our control?            



###Q&A
1. How do you decide which technology to learn and invest time in?             
Try to focus on a few key things:
What are the absolute must-have technical requirements for whatever I am working on?   -- Distributed System design, Algorithms, Low Level Design   
Accept that you can’t learn everything, but you can learn enough to be effective. It’s good to find a balance in what you choose to learn to keep yourself effective. When you pick just a few, high-impact choices you set yourself up to have enough time to get more depth in your technology of choice. This can be immensely useful when you’re trying to building anything non-trivial in the real world.     

2. Think about the best programmer you’ve ever worked with. What did they do constantly that makes you think that way?  
- People that always had a good schedule/agenda in their lives. They were always on time, starting and finishing their workday on the perfect hour every single day. All of these people showed me that I would only win if I could smartly organize my day and avoid procrastination.      
- They are reliable. And you can’t have consistency without reliability. They know that it’s not worth it to work long hours through the night because the next day, you won’t be rested enough to think clearly. They know that it’s essential to have fun, eat well.            
- They don’t give estimations based on perfect conditions. Because they know it’s rare to get a full day without distractions - a full day of just programming.     
- They know that there are meetings, that things can explode in production, and that they will need to help others navigate the source code.        
- The best programmers were all extremely disciplined. They always had the time to write great code, add comprehensive test coverage, and explain the nitty-gritty details through detailed commit messages. These disciplined developers don’t work all through the night and stress about shipping the next feature. They invest their time in doing things well and communicating clearly.       

3. How do you estimate tasks?       
I think the best estimation is no estimation. Sometimes saying ‘no’ isn’t an option though. When I can’t say no, I do what I assume every other engineer does in that situation, guess. Guessing doesn’t mean that you should scream YOLO and shout a random duration of time, but use your past experiences and best judgment to make the most educated guess you can. Once you have that estimate, multiply it by 2. I’ve seen plenty of people get upset when software was delivered late, but I’ve never seen anyone get angry at software being delivered early. If you live by ‘under-promise and over-deliver’ when it comes to software estimates, you’ll be in good company.           

4. Stop wasting time on variables that are out of your control. Focus on the variables that you can change        
- Variables that you can control:
    - Your thoughts     
    - Who your friends are      
    - What you eat and drink        
    - How you spend your money      
    - What you do with your time        
    - How you treat your body       
    - How much you appreciate the things you already have       
- Variables that you cannot control:
    - The weather       
    - The economy       
    - The public health     
    - How people treat you      
    - What people think of you      
    - What people like or dislike       
    - What happened in the past     

###Notes  
- If you decide to become a great developer, it’s important to understand core concepts such as algorithms, logic, network, accessibility, security, and user experience.      
- If you really want to learn something, you have to teach it. 
The process of digesting content to someone is what makes you really understand it. 
The process of writing down how to do something is what makes you memorize it. 
**The process of teaching is what makes you truly learn it.**            
- Discipline. Consistency. Persistency. Those concepts are not sexy at all, but they are the key to playing infinite games.        
- Programmers who are playing the finite game are focused on their bonus at the end of the year or waiting for that freelance project to end. Whereas programmers who are playing the infinite game are less worried about intensity and are more focused on consistency.       
- You need to write for your future self. Your current self has all the context needed to understand that block of code, whereas your future self will be involved with other things and probably won’t even remember what that function X means. Don’t try to be clever, don’t try to code something to make you feel smarter, you don’t need to show off all the new tricks you just learned. Just write readable code. Think about maintainability, and use meaningful names for your classes, functions, and variables. Next time you start developing, ask yourself this question: “Will the future me understand the intention of this code?”     
- The second key point is very famous, but surprisingly difficult to put into practice: early optimization is the root of all evil.         
- Another aspect is to always test everything you write. Unit testing, integration testing, performance/benchmark testing, all of it. Enforcing a simple policy of ‘no new code without unit tests,’ for example, can work wonders.     
- A person who knows how to code is powerful, **a person who knows how to code and knows how business works is unstoppable.**       

 